# author: Nicolas Tessore <n.tessore@ucl.ac.uk>
# license: MIT
'''random fields'''

__all__ = [
    'RandomField',
    'NormalField',
    'LognormalField',
]


import numpy as np
import healpy as hp
import logging
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass, fields as dataclass_fields
from sortcl import cl_indices
from gaussiancl import (
    lognormal_cl,
    lognormal_normal_cl,
)

from .types import get_default_ref, Annotated, ArrayLike, NumberOfBins, ClsDict


log = logging.getLogger('glass.random')


class RandomFieldMeta(ABCMeta):
    '''metaclass for random fields

    Is an abstract base class with subscripting for type hinting.

    '''

    def __getitem__(cls, T):
        '''subscripting for type hinting'''

        return Annotated[cls, get_default_ref(T)]


@dataclass
class RandomField(metaclass=RandomFieldMeta):
    '''abstract base class for transformed Gaussian random fields

    Abstract base class for parametric random fields that are generated by
    transforming Gaussian random fields.  Such random fields are generated
    from Cls.

    Transformations are always applied in place.
    '''

    mean: ArrayLike = 0.0

    @classmethod
    def parameters(cls) -> tuple[str]:
        return tuple(f.name for f in dataclass_fields(cls))

    @abstractmethod
    def __call__(self, field: ArrayLike, var_in: ArrayLike, var_out: ArrayLike) -> ArrayLike:
        pass


@dataclass
class NormalField(RandomField):
    '''normal random field'''

    def __call__(self, field: ArrayLike, var_in: ArrayLike, var_out: ArrayLike) -> ArrayLike:
        # add axis for pixels
        mean = np.asarray(self.mean)[..., np.newaxis]
        # add mean to Gaussian field
        field += mean
        return field


@dataclass
class LognormalField(RandomField):
    '''lognormal random field'''

    shift: float = 1.0

    def __call__(self, field: ArrayLike, var_in: ArrayLike, var_out: ArrayLike) -> ArrayLike:
        # add axis for pixels
        mean = np.asarray(self.mean)[..., np.newaxis]
        shift = np.asarray(self.shift)[..., np.newaxis]
        var_in = np.asarray(var_in)[..., np.newaxis]
        # fix the mean of the Gaussian field
        field += np.log(mean + shift) - var_in/2
        # exponentiate values in place
        np.exp(field, out=field)
        # lognormal shift
        field -= shift
        return field


def generate_random_fields(nside: int,
                           fields: dict[str, RandomField],
                           nbins: NumberOfBins,
                           cls: ClsDict,
                           allow_missing_cls: bool = False) -> ArrayLike:
    '''generate random fields from cls'''

    # debug output computations are expensive, so only do them when necessary
    debug = log.isEnabledFor(logging.DEBUG)

    # expand out the random field definitions for cls
    _names, _dists, _params = [], [], []
    for name, field in fields.items():
        # the names of the individual fields for cls
        _names += [f'{name}[{i}]' for i in range(nbins)]
        # store the distribution type for transformation of cls
        _dists += [field.__class__.__name__]*nbins
        # get all random field parameters broadcast to size nbins
        params = {}
        for par in field.parameters():
            val = getattr(field, par)
            try:
                params[par] = np.broadcast_to(val, nbins, True)
            except ValueError:
                raise ValueError(f'parameter "{par}" of field "{name}" is incompatible with field size {nbins}')
        # transpose dict of arrays into array of dicts
        _params += [dict(zip(params.keys(), values)) for values in zip(*params.values())]

    # total number of fields to simulate
    n = len(_names)

    if debug:
        log.debug('simulating %d random fields:', n)
        for i in range(n):
            log.debug('- %s: %s with %s', _names[i], _dists[i], _params[i])

    # get the cls of the fields
    _cls = []
    for i, j in zip(*cl_indices(n)):
        a, b = _names[i], _names[j]
        if (a, b) in cls:
            _cls.append(cls[a, b])
        elif (b, a) in cls:
            _cls.append(cls[b, a])
        elif allow_missing_cls:
            _cls.append(None)
        else:
            raise KeyError(f'missing cls: ({a}, {b})')

    if debug:
        log.debug('collected %d cls, of which %d are None', len(cls), sum(cl is None for cl in cls))

    # lmax is given by nside
    lmax = 3*nside - 1

    log.debug('nside is %d, lmax from nside is %d', nside, lmax)

    # get the pixel window function
    pw = hp.pixwin(nside, pol=False, lmax=lmax)
    lmax = len(pw) - 1

    log.debug('lmax after pixwin is %d', lmax)

    # variances of the transformed and Gaussian random fields, computed from cls
    var = np.zeros(n)
    gaussian_var = np.zeros(n)

    log.debug('transform cls:')

    # transform to input cls for the Gaussian random fields
    gaussian_cls = []
    for i, j, cl in zip(*cl_indices(n), _cls):
        # only work on available cls
        if cl is not None:
            # simulating integrated fields by multiplying cls and pw
            # shorter array sets length
            cl_len = min(len(cl), lmax+1)
            cl = cl[:cl_len] * pw[:cl_len]

            # compute the variance if on the diagonal
            if i == j:
                l = np.arange(cl_len)
                var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

            # transform the cl
            field_pair = _dists[i], _dists[j]
            field_pars = _params[i], _params[j]

            if field_pair == ('NormalField', 'NormalField'):
                log.debug('- (%s, %s): no transformation', _names[i], _names[j])

            elif field_pair == ('LognormalField', 'NormalField'):
                alpha = field_pars[0]['mean'] + field_pars[0]['shift']
                cl = lognormal_normal_cl(cl, alpha=alpha)

                log.debug('- (%s, %s): lognormal_normal_cl(cl, alpha=%g)', _names[i], _names[j], alpha)

            elif field_pair == ('NormalField', 'LognormalField'):
                alpha = field_pars[1]['mean'] + field_pars[1]['shift']
                cl = lognormal_normal_cl(cl, alpha=alpha)

                log.debug('- (%s, %s): lognormal_normal_cl(cl, alpha=%g)', _names[i], _names[j], alpha)

            elif field_pair == ('LognormalField', 'LognormalField'):
                alpha = field_pars[0]['mean'] + field_pars[0]['shift']
                alpha2 = field_pars[1]['mean'] + field_pars[1]['shift']
                cl = lognormal_cl(cl, alpha=alpha, alpha2=alpha2)

                log.debug('- (%s, %s): lognormal_cl(cl, alpha=%g, alpha2=%g)', _names[i], _names[j], alpha, alpha2)

            else:
                raise TypeError(f'missing transformation for field pair {field_pair}')

            # compute the Gaussian variance if on the diagonal
            if i == j:
                gaussian_var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

        # store the Gaussian cl, or None
        gaussian_cls.append(cl)

    log.debug('sampling alms...')

    # sample the Gaussian random fields in harmonic space
    alms = hp.synalm(gaussian_cls, lmax=lmax, new=True)

    log.debug('computing maps...')

    # compute the Gaussian random field maps in real space
    # can be performed in place because the alms are not needed
    maps = hp.alm2map(alms, nside, lmax=lmax, pixwin=False, pol=False, inplace=True)
    alms = None

    log.debug('transforming fields...')

    # transform the Gaussian random fields to the output fields
    _maps = {}
    for i, (name, field) in enumerate(fields.items()):
        index = np.s_[i*nbins:(i+1)*nbins]

        # output statistics of the Gaussian field before the transformation
        if debug:
            log.debug('- %s:', name)
            log.debug('  - Gaussian field:')
            log.debug('    - min: %s', np.array_str(np.min(maps[index], axis=-1), np.inf))
            log.debug('    - max: %s', np.array_str(np.max(maps[index], axis=-1), np.inf))
            log.debug('    - mean: %s', np.array_str(np.mean(maps[index], axis=-1), np.inf))
            log.debug('    - var: %s', np.array_str(np.var(maps[index], axis=-1), np.inf))
            log.debug('    - Evar: %s', np.array_str(gaussian_var[index], np.inf))

        # do the transformation
        _maps[name] = field(maps[index], var_in=gaussian_var[index], var_out=var[index])

        # output statistics of the desired field after the transformation
        if debug:
            log.debug('  - %s:', field.__class__.__name__)
            log.debug('    - min: %s', np.array_str(np.min(maps[index], axis=-1), np.inf))
            log.debug('    - max: %s', np.array_str(np.max(maps[index], axis=-1), np.inf))
            log.debug('    - mean: %s', np.array_str(np.mean(maps[index], axis=-1), np.inf))
            log.debug('    - Emean: %s', np.array_str(np.asarray(field.mean), np.inf))
            log.debug('    - var: %s', np.array_str(np.var(maps[index], axis=-1), np.inf))
            log.debug('    - Evar: %s', np.array_str(var[index], np.inf))

    log.debug('random fields generated')

    # fields have been created
    return _maps
