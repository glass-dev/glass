# author: Nicolas Tessore <n.tessore@ucl.ac.uk>
# license: MIT
'''random fields'''

__all__ = [
    'RandomField',
    'NormalField',
    'LognormalField',
]


import numpy as np
import healpy as hp
import logging
import gaussiancl
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass, fields as dataclass_fields
from functools import singledispatchmethod, partial
from sortcl import cl_indices

from .types import ArrayLike, ClsList
from .numeric import cov_reg_simple, cov_reg_keepdiag


log = logging.getLogger('glass.random')


@dataclass
class RandomField(metaclass=ABCMeta):
    '''abstract base class for transformed Gaussian random fields

    Abstract base class for parametric random fields that are generated by
    transforming Gaussian random fields.  Such random fields are generated
    from Cls.

    Transformations are always applied in place.
    '''

    mean: float = 0.0

    @classmethod
    def parameters(cls) -> tuple[str]:
        return tuple(f.name for f in dataclass_fields(cls))

    @abstractmethod
    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        pass

    @abstractmethod
    def gaussiancl(self, other):
        return NotImplemented

    def __and__(self, other):
        return self.gaussiancl(other)

    def __rand__(self, other):
        return self.gaussiancl(other)


@dataclass
class NormalField(RandomField):
    '''normal random field'''

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # add mean to Gaussian field
        field += self.mean
        return field

    @singledispatchmethod
    def gaussiancl(self, other):
        if type(other) != type(self):
            return NotImplemented

        return lambda cl: cl


@dataclass
class LognormalField(RandomField):
    '''lognormal random field'''

    shift: float = 1.0

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # fix the mean of the Gaussian field
        field += np.log(self.mean + self.shift) - var_in/2
        # exponentiate values in place
        np.exp(field, out=field)
        # lognormal shift
        field -= self.shift
        return field

    @singledispatchmethod
    def gaussiancl(self, other):
        if type(other) != type(self):
            return NotImplemented

        alpha = self.mean + self.shift
        alpha2 = other.mean + other.shift
        return partial(gaussiancl.lognormal_cl, alpha=alpha, alpha2=alpha2)

    @gaussiancl.register
    def _(self, other: NormalField):
        alpha = self.mean + self.shift
        return partial(gaussiancl.lognormal_normal_cl, alpha=alpha)


def generate_random_fields(nside: int,
                           fields: list[RandomField],
                           cls: ClsList,
                           reg: str = 'simple') -> ArrayLike:
    '''generate random fields from cls'''

    # debug output computations are expensive, so only do them when necessary
    debug = log.isEnabledFor(logging.DEBUG)

    # total number of fields to simulate
    n = len(fields)

    if debug:
        log.debug('simulating %d random fields:', n)
        for field in fields:
            log.debug('- %s', field)

    # lmax is given by nside
    lmax = 3*nside - 1

    log.debug('nside is %d, lmax from nside is %d', nside, lmax)

    # get the pixel window function
    pw = hp.pixwin(nside, pol=False, lmax=lmax)
    lmax = len(pw) - 1

    log.debug('lmax after pixwin is %d', lmax)

    # array to compute variance, used a couple of times below
    two_l_plus_1_over_four_pi = (2*np.arange(lmax+1)+1)/(4*np.pi)

    # variances of the transformed and Gaussian random fields, computed from cls
    var = np.zeros(n)
    gaussian_var = np.zeros(n)

    log.debug('transform cls...')

    # covariance matrix of cls
    cov = np.zeros((lmax+1, n, n), dtype=float)

    # transform to input cls for the Gaussian random fields
    for i, j, cl in zip(*cl_indices(n), cls):
        # only work on available cls
        if cl is not None:
            # pad shorter arrays with zero
            # this makes a copy of cl so we are not changing the input
            if len(cl) < lmax+1:
                cl = np.pad(cl, (0, lmax+1-len(cl)))
            else:
                cl = np.copy(cl[:lmax+1])

            # simulating integrated fields by multiplying cls and pw
            cl *= pw

            # extra checks on the diagonal
            if i == j:
                # autocorrelation must be nonnegative
                if np.any(cl < 0):
                    log.warn('WARNING: negative cls for field %d', i)

                # compute the variance if on the diagonal
                var[i] = two_l_plus_1_over_four_pi@cl

            # store monopole and dipole if zero
            has_monopole = (cl[0] != 0)
            has_dipole = (cl[1] != 0)

            # transform the cl
            cl = (fields[i] & fields[j])(cl)

            # restore monopole and dipole if zero
            cl[0] *= has_monopole
            cl[1] *= has_dipole

            # extra checks on the diagonal
            if i == j:
                # autocorrelation must be nonnegative
                if np.any(cl < 0):
                    log.warn('WARNING: negative Gaussian cls for field %d', i)

            # store the Gaussian cl in matrix (lower triangle only)
            cov[:, j, i] = cl

    log.debug('check covariance matrix...')

    # use cholesky() as a fast way to check for positive semi-definite
    try:
        np.linalg.cholesky(cov + np.finfo(0.).tiny)
    except np.linalg.LinAlgError:
        # matrix needs regularisation
        do_reg = True
    else:
        # matrix is ok
        do_reg = False

    # perform the regularisation if necessary
    if do_reg:
        log.info('cls require regularisation!')

        log.debug('covariance matrix regularisation...')
        log.debug('regularisation method: %s', reg)

        if reg is None:
            reg = cov
        elif reg == 'simple':
            reg = cov_reg_simple(cov)
        elif reg == 'keepdiag':
            reg = cov_reg_keepdiag(cov)
        else:
            raise ValueError(f'unknown method "{reg}" for regularisation')

        # show the maximum change in each l
        if debug:
            # get the diagonal of covariance matrix and regularised
            _diag_cov = cov.reshape(lmax+1, -1)[:, ::n+1]
            _diag_reg = reg.reshape(lmax+1, -1)[:, ::n+1]

            _abs = np.fabs(_diag_reg - _diag_cov)
            _rel = np.divide(_abs, np.fabs(_diag_cov), where=(_diag_cov != 0), out=np.zeros_like(_abs))
            _max_abs = np.max(_abs, axis=-1)
            _max_rel = np.max(_rel, axis=-1)
            _argmax_abs = np.argmax(_max_abs)
            _argmax_rel = np.argmax(_max_rel)
            with np.printoptions(precision=3, linewidth=np.inf, floatmode='fixed', sign=' '):
                log.debug('maximum absolute change in autocorrelation: %g [l = %d]', _max_abs[_argmax_abs], _argmax_abs)
                log.debug('before:')
                log.debug('%s', cov[_argmax_abs].diagonal())
                log.debug('after:')
                log.debug('%s', reg[_argmax_abs].diagonal())
                log.debug('maximum relative change in autocorrelation: %g [l = %d]', _max_rel[_argmax_rel], _argmax_rel)
                log.debug('before:')
                log.debug('%s', cov[_argmax_rel].diagonal())
                log.debug('after:')
                log.debug('%s', reg[_argmax_rel].diagonal())

        # use the regularised covariance matrix, free up the old array
        cov = reg

    # gather list of Gaussian cls
    gaussian_cls = []
    for k, (i, j) in enumerate(zip(*cl_indices(n))):
        # grab the cl from the lower triangular covariance matrix
        cl = cov[:, j, i]

        # store in the list, which thus has the synalm order
        gaussian_cls.append(cl)

        # compute the Gaussian variance if on the diagonal
        if i == j:
            gaussian_var[i] = two_l_plus_1_over_four_pi@cl

    log.debug('sampling alms...')

    # sample the Gaussian random fields in harmonic space
    alms = hp.synalm(gaussian_cls, lmax=lmax, new=True)

    if debug:
        for i, alm in enumerate(alms):
            cl = hp.alm2cl(alm)
            l = np.arange(len(cl))
            _mean = np.sqrt(4*np.pi*cl[0])
            _var = np.sum((2*l+1)/(4*np.pi)*cl)
            log.debug('- mean: %g [%g]', _mean, 0.)
            log.debug('  var: %g [%g]', _var, gaussian_var[i])

    log.debug('computing maps...')

    # compute the Gaussian random field maps in real space
    # can be performed in place because the alms are not needed
    maps = hp.alm2map(alms, nside, lmax=lmax, pixwin=False, pol=False, inplace=True)
    alms = None

    if debug:
        for i, m in enumerate(maps):
            log.debug('- mean: %g [%g]', np.mean(m), fields[i].mean)
            log.debug('  var: %g [%g]', np.var(m), gaussian_var[i])
            log.debug('  min: %g', np.min(m))
            log.debug('  max: %g', np.max(m))

    log.debug('transforming fields...')

    # transform the Gaussian random fields to the output fields
    for i, field in enumerate(fields):
        maps[i] = field(maps[i], var_in=gaussian_var[i], var_out=var[i])

    if debug:
        for i, m in enumerate(maps):
            log.debug('- mean: %g [%g]', np.mean(m), fields[i].mean)
            log.debug('  var: %g [%g]', np.var(m), var[i])
            log.debug('  min: %g', np.min(m))
            log.debug('  max: %g', np.max(m))

    log.debug('random fields generated')

    # fields have been created
    return maps
