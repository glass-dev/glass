# author: Nicolas Tessore <n.tessore@ucl.ac.uk>
# license: MIT
'''random fields'''

__all__ = [
    'RandomField',
    'NormalField',
    'LognormalField',
]


import numpy as np
import healpy as hp
import logging
import gaussiancl
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass, fields as dataclass_fields
from functools import singledispatchmethod, partial
from sortcl import cl_indices

from .types import ArrayLike, ClsList


log = logging.getLogger('glass.random')


@dataclass
class RandomField(metaclass=ABCMeta):
    '''abstract base class for transformed Gaussian random fields

    Abstract base class for parametric random fields that are generated by
    transforming Gaussian random fields.  Such random fields are generated
    from Cls.

    Transformations are always applied in place.
    '''

    mean: float = 0.0

    @classmethod
    def parameters(cls) -> tuple[str]:
        return tuple(f.name for f in dataclass_fields(cls))

    @abstractmethod
    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        pass

    @abstractmethod
    def gaussiancl(self, other):
        return NotImplemented

    def __and__(self, other):
        return self.gaussiancl(other)

    def __rand__(self, other):
        return self.gaussiancl(other)


@dataclass
class NormalField(RandomField):
    '''normal random field'''

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # add mean to Gaussian field
        field += self.mean
        return field

    @singledispatchmethod
    def gaussiancl(self, other):
        if type(other) != type(self):
            return NotImplemented

        return lambda cl: cl


@dataclass
class LognormalField(RandomField):
    '''lognormal random field'''

    shift: float = 1.0

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # fix the mean of the Gaussian field
        field += np.log(self.mean + self.shift) - var_in/2
        # exponentiate values in place
        np.exp(field, out=field)
        # lognormal shift
        field -= self.shift
        return field

    @singledispatchmethod
    def gaussiancl(self, other):
        if type(other) != type(self):
            return NotImplemented

        alpha = self.mean + self.shift
        alpha2 = other.mean + other.shift
        return partial(gaussiancl.lognormal_cl, alpha=alpha, alpha2=alpha2)

    @gaussiancl.register
    def _(self, other: NormalField):
        alpha = self.mean + self.shift
        return partial(gaussiancl.lognormal_normal_cl, alpha=alpha)


def generate_random_fields(nside: int, fields: list[RandomField], cls: ClsList) -> ArrayLike:
    '''generate random fields from cls'''

    # debug output computations are expensive, so only do them when necessary
    debug = log.isEnabledFor(logging.DEBUG)

    # total number of fields to simulate
    n = len(fields)

    if debug:
        log.debug('simulating %d random fields:', n)
        for field in fields:
            log.debug('- %s', field)

    # lmax is given by nside
    lmax = 3*nside - 1

    log.debug('nside is %d, lmax from nside is %d', nside, lmax)

    # get the pixel window function
    pw = hp.pixwin(nside, pol=False, lmax=lmax)
    lmax = len(pw) - 1

    log.debug('lmax after pixwin is %d', lmax)

    # variances of the transformed and Gaussian random fields, computed from cls
    var = np.zeros(n)
    gaussian_var = np.zeros(n)

    log.debug('transform cls:')

    # transform to input cls for the Gaussian random fields
    gaussian_cls = []
    for i, j, cl in zip(*cl_indices(n), cls):
        # only work on available cls
        if cl is not None:
            # simulating integrated fields by multiplying cls and pw
            # shorter array sets length
            cl_len = min(len(cl), lmax+1)
            cl = cl[:cl_len] * pw[:cl_len]

            # compute the variance if on the diagonal
            if i == j:
                l = np.arange(cl_len)
                var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

            # transform the cl
            cl = (fields[i] & fields[j])(cl)

            # compute the Gaussian variance if on the diagonal
            if i == j:
                gaussian_var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

        # store the Gaussian cl, or None
        gaussian_cls.append(cl)

    log.debug('sampling alms...')

    # sample the Gaussian random fields in harmonic space
    alms = hp.synalm(gaussian_cls, lmax=lmax, new=True)

    if debug:
        for i, alm in enumerate(alms):
            cl = hp.alm2cl(alm)
            l = np.arange(len(cl))
            _mean = np.sqrt(4*np.pi*cl[0])
            _var = np.sum((2*l+1)/(4*np.pi)*cl)
            log.debug('- mean: %g [%g]', _mean, 0.)
            log.debug('  var: %g [%g]', _var, gaussian_var[i])

    log.debug('computing maps...')

    # compute the Gaussian random field maps in real space
    # can be performed in place because the alms are not needed
    maps = hp.alm2map(alms, nside, lmax=lmax, pixwin=False, pol=False, inplace=True)
    alms = None

    if debug:
        for i, m in enumerate(maps):
            log.debug('- mean: %g [%g]', np.mean(m), fields[i].mean)
            log.debug('  var: %g [%g]', np.var(m), gaussian_var[i])
            log.debug('  min: %g', np.min(m))
            log.debug('  max: %g', np.max(m))

    log.debug('transforming fields...')

    # transform the Gaussian random fields to the output fields
    for i, field in enumerate(fields):
        maps[i] = field(maps[i], var_in=gaussian_var[i], var_out=var[i])

    if debug:
        for i, m in enumerate(maps):
            log.debug('- mean: %g [%g]', np.mean(m), fields[i].mean)
            log.debug('  var: %g [%g]', np.var(m), var[i])
            log.debug('  min: %g', np.min(m))
            log.debug('  max: %g', np.max(m))

    log.debug('random fields generated')

    # fields have been created
    return maps
