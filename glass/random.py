# author: Nicolas Tessore <n.tessore@ucl.ac.uk>
# license: MIT
'''random fields'''

__all__ = [
    'RandomField',
    'NormalField',
    'LognormalField',
]


import numpy as np
import healpy as hp
import logging
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass, fields as dataclass_fields
from sortcl import cl_indices
from gaussiancl import (
    lognormal_cl,
    lognormal_normal_cl,
)

from .types import ArrayLike, ClsList


log = logging.getLogger('glass.random')


@dataclass
class RandomField(metaclass=ABCMeta):
    '''abstract base class for transformed Gaussian random fields

    Abstract base class for parametric random fields that are generated by
    transforming Gaussian random fields.  Such random fields are generated
    from Cls.

    Transformations are always applied in place.
    '''

    mean: float = 0.0

    @classmethod
    def parameters(cls) -> tuple[str]:
        return tuple(f.name for f in dataclass_fields(cls))

    @abstractmethod
    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        pass


@dataclass
class NormalField(RandomField):
    '''normal random field'''

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # add mean to Gaussian field
        field += self.mean
        return field


@dataclass
class LognormalField(RandomField):
    '''lognormal random field'''

    shift: float = 1.0

    def __call__(self, field: ArrayLike, var_in: float, var_out: float) -> ArrayLike:
        # fix the mean of the Gaussian field
        field += np.log(self.mean + self.shift) - var_in/2
        # exponentiate values in place
        np.exp(field, out=field)
        # lognormal shift
        field -= self.shift
        return field


def generate_random_fields(nside: int, fields: list[RandomField], cls: ClsList) -> ArrayLike:
    '''generate random fields from cls'''

    # debug output computations are expensive, so only do them when necessary
    debug = log.isEnabledFor(logging.DEBUG)

    # total number of fields to simulate
    n = len(fields)

    if debug:
        log.debug('simulating %d random fields:', n)
        for field in fields:
            log.debug('- %s', field)

    # lmax is given by nside
    lmax = 3*nside - 1

    log.debug('nside is %d, lmax from nside is %d', nside, lmax)

    # get the pixel window function
    pw = hp.pixwin(nside, pol=False, lmax=lmax)
    lmax = len(pw) - 1

    log.debug('lmax after pixwin is %d', lmax)

    # variances of the transformed and Gaussian random fields, computed from cls
    var = np.zeros(n)
    gaussian_var = np.zeros(n)

    log.debug('transform cls:')

    # transform to input cls for the Gaussian random fields
    gaussian_cls = []
    for i, j, cl in zip(*cl_indices(n), cls):
        # only work on available cls
        if cl is not None:
            # simulating integrated fields by multiplying cls and pw
            # shorter array sets length
            cl_len = min(len(cl), lmax+1)
            cl = cl[:cl_len] * pw[:cl_len]

            # compute the variance if on the diagonal
            if i == j:
                l = np.arange(cl_len)
                var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

            # transform the cl
            field_pair = (type(fields[i]), type(fields[j]))

            if field_pair == (NormalField, NormalField):
                log.debug('- %s: no transformation', field_pair)

            elif field_pair == (LognormalField, NormalField):
                alpha = fields[i].mean + fields[i].shift
                cl = lognormal_normal_cl(cl, alpha=alpha)

                log.debug('- %s: lognormal_normal_cl(cl, alpha=%g)', field_pair, alpha)

            elif field_pair == (NormalField, LognormalField):
                alpha = fields[j].mean + fields[j].shift
                cl = lognormal_normal_cl(cl, alpha=alpha)

                log.debug('- %s: lognormal_normal_cl(cl, alpha=%g)', field_pair, alpha)

            elif field_pair == (LognormalField, LognormalField):
                alpha = fields[i].mean + fields[j].shift
                alpha2 = fields[j].mean + fields[j].shift
                cl = lognormal_cl(cl, alpha=alpha, alpha2=alpha2)

                log.debug('- %s: lognormal_cl(cl, alpha=%g, alpha2=%g)', field_pair, alpha, alpha2)

            else:
                raise TypeError(f'missing transformation for field pair {field_pair}')

            # compute the Gaussian variance if on the diagonal
            if i == j:
                gaussian_var[i] = np.sum((2*l+1)/(4*np.pi)*cl)

        # store the Gaussian cl, or None
        gaussian_cls.append(cl)

    log.debug('sampling alms...')

    # sample the Gaussian random fields in harmonic space
    alms = hp.synalm(gaussian_cls, lmax=lmax, new=True)

    log.debug('computing maps...')

    # compute the Gaussian random field maps in real space
    # can be performed in place because the alms are not needed
    maps = hp.alm2map(alms, nside, lmax=lmax, pixwin=False, pol=False, inplace=True)
    alms = None

    log.debug('transforming fields...')

    # transform the Gaussian random fields to the output fields
    for i, field in enumerate(fields):

        # statistics of the Gaussian field before the transformation
        if debug:
            _min = np.min(maps[i])
            _max = np.max(maps[i])
            _mean = np.mean(maps[i])
            _var = np.var(maps[i])

        # do the transformation
        maps[i] = field(maps[i], var_in=gaussian_var[i], var_out=var[i])

        # output statistics of the desired field after the transformation
        if debug:
            log.debug('- Gaussian -> %s:', field.__class__.__name__)
            log.debug('  - min: %g -> %g', _min, np.min(maps[i]))
            log.debug('  - max: %g -> %g', _max, np.max(maps[i]))
            log.debug('  - mean: %g -> %g', _mean, np.mean(maps[i]))
            log.debug('  - Emean: %g -> %g', 0., field.mean)
            log.debug('  - var: %g -> %g', _var, np.var(maps[i]))
            log.debug('  - Evar: %g -> %g', gaussian_var[i], var[i])

    log.debug('random fields generated')

    # fields have been created
    return maps
